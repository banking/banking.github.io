<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>banking acticles</title>
    <description>I am a Newcomer @ git.io-jekyll.
</description>
    <link>http://yourdomain.com/</link>
    <atom:link href="http://yourdomain.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 23 Sep 2016 15:33:16 +0800</pubDate>
    <lastBuildDate>Fri, 23 Sep 2016 15:33:16 +0800</lastBuildDate>
    <generator>Jekyll v3.1.2</generator>
    
      <item>
        <title>学习github上的android开源工程</title>
        <description>
</description>
        <pubDate>Fri, 19 Aug 2016 12:09:08 +0800</pubDate>
        <link>http://yourdomain.com/learn/android/2016/08/19/learn-android-github-source-code.html</link>
        <guid isPermaLink="true">http://yourdomain.com/learn/android/2016/08/19/learn-android-github-source-code.html</guid>
        
        
        <category>Learn</category>
        
        <category>Android</category>
        
      </item>
    
      <item>
        <title>Mac上超级好用的效率工具</title>
        <description>&lt;p&gt;Mac上的高效工具。  &lt;br /&gt;
#1.Alfred
目前稳定版是Alfred 2,Alfred 3添加了很多新功能，推荐使用。 &lt;br /&gt;
Alfred某种程度上是spotlight替代品；支持更多自定义和其他关联功能。 &lt;br /&gt;
&lt;strong&gt;免费版支持功能&lt;/strong&gt; &lt;br /&gt;
1.关键词查找特定类型本地文件/应用程序 &lt;br /&gt;
2.自定义Web Search：比如通过简单配置，终端输入「JD iphone」可以直接在京东搜索iphone &lt;br /&gt;
3.关联计算器：在终端输入计算器语法，直接给出结果 &lt;br /&gt;
4.词典关联翻译 &lt;br /&gt;
&lt;strong&gt;付费版解锁功能&lt;/strong&gt;  &lt;br /&gt;
1.Workflow功能:跳转Chrome到固定分页
2.关联联系人 &lt;br /&gt;
3.直接执行iTerm命令 &lt;br /&gt;
4.支持关联自定义词典:    &lt;br /&gt;
github上有很多优秀的词典,比如这一款： &lt;br /&gt;
https://github.com/liberize/alfred-dict-workflow &lt;br /&gt;
5.关联1Password &lt;br /&gt;
6.管理检索剪贴板&lt;/p&gt;

&lt;p&gt;#2.1Password
1Password是一款强大的密码管理软件，特点是用一个主密码管理所有Web，App密码；多终端同步。 &lt;br /&gt;
1Password试用版有30天试用期，过试用期之后，还能使用，但无法继续添加新的密码项。 &lt;br /&gt;
&lt;strong&gt;安全性&lt;/strong&gt;
推荐所有密码项都选择6-10位的随机密码，这样不会存在一家网站密码泄露，威胁其他账号的情况。&lt;br /&gt;
本地加密（256位AES），本地储存；应用程序开发商也无法开启。 &lt;br /&gt;
网络云同步（iCloud/Dropbox)数据也是加密后之后才同步。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方便&lt;/strong&gt;
1.顾名思义，你只需要记住一个主密码，管理你的其他账户密码。
2.多终端同步，登陆账户即可。覆盖Windows,Mac,iphone,Android等多终端环境，无痛迁移。
3.浏览器上可以一键填充密码（Mac上默认是command + |)。  &lt;br /&gt;
4.浏览器上完成账号注册，密码修改；都会提示一键添加到1Password密码管理项中。&lt;/p&gt;

</description>
        <pubDate>Fri, 27 May 2016 16:30:19 +0800</pubDate>
        <link>http://yourdomain.com/tools/2016/05/27/mac-tools.html</link>
        <guid isPermaLink="true">http://yourdomain.com/tools/2016/05/27/mac-tools.html</guid>
        
        
        <category>tools</category>
        
      </item>
    
      <item>
        <title>好用的工具汇总</title>
        <description>&lt;p&gt;&lt;strong&gt;翻墙工具：Envacurpt&lt;/strong&gt;&lt;br /&gt;
推荐购买 SSLedge Pro;价格是 600￥/year &lt;br /&gt;
官网: https://eurekavpt.com/ ；官网有详细介绍  &lt;br /&gt;
Mac使用文档：https://eurekavpt.com/page/use-ssledge-on-mac     &lt;br /&gt;
需要的私信我要注册码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;微信公众号&lt;/strong&gt; &lt;br /&gt;
1.按住快捷键Ctrl+Alt+M，对Markdown文章进行渲染 &lt;br /&gt;
2.封面头图，图片尺寸官方建议的是360x200像素，但是呢在手机微信上显示的图片会被标题挡住一部分。 &lt;br /&gt;
3.多图文的二级缩略图是四方型显示的，那么图片最佳尺寸为200x200，或者宽、高相等不超过500为好。&lt;/p&gt;
</description>
        <pubDate>Thu, 19 May 2016 18:09:57 +0800</pubDate>
        <link>http://yourdomain.com/tools/2016/05/19/web-page-tools.html</link>
        <guid isPermaLink="true">http://yourdomain.com/tools/2016/05/19/web-page-tools.html</guid>
        
        
        <category>tools</category>
        
      </item>
    
      <item>
        <title>通过Mat利器OQL分析Android App内存</title>
        <description>&lt;p&gt;内存分析离不开Mat,在Mat上接触到了OQL.
另：OQL对宏观上了解App组件的和JVM虚拟机的学习，也大有益处。&lt;/p&gt;

&lt;h1 id=&quot;oql&quot;&gt;1.什么是OQL，如何使用&lt;/h1&gt;

&lt;p&gt;Analyzing a Heap Dump Using Object Query Language,分析Java heap dump有重要意义。&lt;/p&gt;

&lt;p&gt;There may be more than one Java class with the same name but loaded by different loader.&lt;/p&gt;

&lt;p&gt;在Mat中使用OQL：分析详细，对了解工程代码有很多好处。
缺点是：dump分析一次，操作略复杂。&lt;/p&gt;

&lt;h1 id=&quot;oql-1&quot;&gt;2.OQL语法简介&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;OQL支持的关键字&lt;/strong&gt;
OQL是类似SQL的一种语法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;OQL语法特性&lt;/strong&gt;
INSTANCEOF关键字:查找属于某父类，实现某接口对象。&lt;/p&gt;

&lt;p&gt;@usedHeapSize：对象属性，获取占用内存值
@retainedHeapSize：对象属性，获取包含引用对象占用总内存值
@GCRootInfo：对象的垃圾回收根节点，判断是否被引用&lt;/p&gt;

&lt;p&gt;支持正则：”java.lang..*”
&lt;strong&gt;使用技巧&lt;/strong&gt;
常见Mat中使用，关心目标对象的占用内存(usedHeapSize)，引用对象占用内存（retainedHeapSize）。推荐在Select语句中标记显示这些属性。
下面是一条OQL： &lt;br /&gt;
SELECT s AS Value, s.@usedHeapSize AS “Shallow Size”, s.@retainedHeapSize AS “Retained Size” FROM INSTANCEOF android.content.BroadcastReceiver s&lt;/p&gt;

&lt;h1 id=&quot;androidoql&quot;&gt;3.Android中通用的OQL语句&lt;/h1&gt;

&lt;p&gt;1.查找所有Activity:  &lt;br /&gt;
作用：过滤出所有Activity实例。检查Activity泄露 &lt;br /&gt;
语句： SELECT * FROM INSTANCEOF android.support.v4.app.FragmentActivity  &lt;br /&gt;
说明：android.support.v4.app.FragmentActivity 可以替换为android.app.Activity；多个相同Activity实例可能存在泄露&lt;/p&gt;

&lt;p&gt;2.查找所有Fragment: &lt;br /&gt;
作用：查看Fragment泄露,如ViewPager多次切换可能泄露Fragment   实例 &lt;br /&gt;
语句：SELECT f AS Value, f.@usedHeapSize AS “Shallow Size”, f.@retainedHeapSize AS “Retained Size” FROM INSTANCEOF android.support.v4.app.Fragment f&lt;br /&gt;
说明：多个相同fragment实例可能存在泄露，同Activity&lt;/p&gt;

&lt;p&gt;3.SELECT file.path.toString() FROM java.io.File file
作用：查看文件目录&lt;/p&gt;

&lt;p&gt;4.查看所有字符串 &lt;br /&gt;
SELECT toString(s) AS Value, s.@usedHeapSize AS “Shallow Size”, s.@retainedHeapSize AS “Retained Size” FROM java.lang.String s&lt;/p&gt;

&lt;h1 id=&quot;oql-2&quot;&gt;4.业务使用的OQL语句&lt;/h1&gt;
&lt;p&gt;1.查找所有自定义Widget:&lt;br /&gt;
比如说我现在项目的自定义Widget，都放在了com.didi.theonebts.widget包中，可以这样写OQL： &lt;br /&gt;
SELECT widget AS Value, widget.@usedHeapSize AS “Shallow Size”, widget.@retainedHeapSize AS “Retained Size” FROM INSTANCEOF “com.didi.theonebts.widget.*” widget &lt;br /&gt;
2.SELECT classof(cl) AS VALUE FROM INSTANCEOF java.lang.ClassLoader cl 
查到所有的classloader&lt;/p&gt;

&lt;p&gt;#5.OQL Report&lt;/p&gt;

&lt;p&gt;参考文献
更多官方语法：
http://help.eclipse.org/mars/index.jsp?topic=%2Forg.eclipse.mat.ui.help%2Freference%2Foqlsyntax.html&lt;/p&gt;
</description>
        <pubDate>Wed, 11 May 2016 10:41:17 +0800</pubDate>
        <link>http://yourdomain.com/android/optimize/2016/05/11/android-memory-analyse-by-oql.html</link>
        <guid isPermaLink="true">http://yourdomain.com/android/optimize/2016/05/11/android-memory-analyse-by-oql.html</guid>
        
        
        <category>Android</category>
        
        <category>Optimize</category>
        
      </item>
    
      <item>
        <title>Android MultiDex启动优化</title>
        <description>&lt;p&gt;Todo  &lt;br /&gt;
According to:http://jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/1218/3789.html&lt;/p&gt;
</description>
        <pubDate>Mon, 09 May 2016 14:04:57 +0800</pubDate>
        <link>http://yourdomain.com/android/optimize/2016/05/09/android-multidex-optimize.html</link>
        <guid isPermaLink="true">http://yourdomain.com/android/optimize/2016/05/09/android-multidex-optimize.html</guid>
        
        
        <category>Android</category>
        
        <category>Optimize</category>
        
      </item>
    
      <item>
        <title>Android测量页面启动时间</title>
        <description>&lt;p&gt;最近在做Android App性能优化，总结一下页面启动时间的测量方法。&lt;/p&gt;

&lt;h1 id=&quot;activity&quot;&gt;1.Activity启动时间&lt;/h1&gt;

&lt;p&gt;Activity启动时会有onCreate/onStart/onResume这些回调，片面的在onResume回调时就认为Activity启动完成是不准确的。因为这时并没有真正执行View.onInflate().对于用户体验而言，应该归结到View第一帧绘制完成 &lt;sub&gt;&lt;font color=&quot;0099ff&quot; face=&quot;黑体&quot;&gt;[1]&lt;/font&gt;&lt;/sub&gt; 。&lt;br /&gt;
以下的统计方法，都是以View绘制完成作为启动时间统计标准的。 &lt;br /&gt;
实际中，建议统计结果为5次的平均值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.ActivityManager Log.&lt;/strong&gt;  &lt;br /&gt;
Android系统的ActivityManager提供了Activity页面启动时间参数日志。  &lt;br /&gt;
统计方法:在debug日志中，筛选包含”ActivityManager: Displayed”字符串的日志。 &lt;br /&gt;
页面理想参数:350ms. &lt;br /&gt;
该日志统计的是Activity从启动到页面绘制完成时间,关于ActivityManager统计时间细节，可以从源码中看到依据&lt;sub&gt;&lt;font color=&quot;0099ff&quot; face=&quot;黑体&quot;&gt;[2]&lt;/font&gt;&lt;/sub&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.adb shell am&lt;/strong&gt;  &lt;br /&gt;
adb shell start是一项adb常用命令，可以外部调起方式调起Activity,Service,Broadcast等组件。 &lt;br /&gt;
需要注意，Activity必须要在Minifest注册时加export = “true”才可以；该属性管理Activity的外部调起权限。&lt;br /&gt;
命令示例：adb shell am start -W -n “com.sdu.app.debug/com.sdu.app.MainActivity”  &lt;br /&gt;
输出示例： &lt;br /&gt;
&lt;img src=&quot;http://121.42.160.4:8081/launchTest/ActivityManager.png&quot; alt=&quot;Alt text&quot; /&gt; &lt;br /&gt;
 -W: wait for launch to complete 等待加载完成并输出日志  &lt;br /&gt;
参数说明：优先使用waittime作为结果（需要Android 5.0以上）；未输出waittime使用totaltime作为启动Activity的耗时统计结果。 &lt;br /&gt;
适合统计应用程序启动时间的场景。如果应用有一些广告页，可以绕过广告页直接加载MainActivity，得到真实的启动耗时参数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.adb shell screenrecord&lt;/strong&gt; &lt;br /&gt;
通过录屏方式分析app启动时间&lt;sub&gt;&lt;font color=&quot;0099ff&quot; face=&quot;黑体&quot;&gt;[3]&lt;/font&gt;&lt;/sub&gt;。&lt;/p&gt;

&lt;p&gt;操作步骤： &lt;br /&gt;
1.开始录屏
adb shell screenrecord –bugreport /sdcard/video.mp4&lt;/p&gt;

&lt;p&gt;2.正常使用情况下，从Launcher中点击app图标启动app,到主页面MainActivity绘制完成时停止录屏（control+c）.&lt;/p&gt;

&lt;p&gt;3.adb pull /sdcard/video.mp4 ~/Desktop/video.mp4&lt;/p&gt;

&lt;p&gt;4.打开视频播放器（我用的是QuickTime Player)。通过逐帧快进分析两个时刻的时间差（开始时间是Launcher icon被按下，结束时刻是MainActivity绘制完成）。&lt;/p&gt;

&lt;h1 id=&quot;fragment&quot;&gt;2.Fragment启动时间&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;1.DecorView.post&lt;/strong&gt; &lt;br /&gt;
fragment在开发中也是广泛使用，有时有需求需要统计fragment的启动时间。 &lt;br /&gt;
在OnCreate中埋点作为启动开始时间。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
public void onCreate(Bundle savedInstanceState) {
	long startTime = System.currentTimeMillis();   
    super.onCreate(savedInstanceState);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在View.post中埋点作为启动结束时间。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;getWindow().getDecorView().post(new Runnable() {
  @Override
  public void run() {
    myHandler.post(mLoadingRunnable);
  }
});
private Handler myHandler = new Handler();
private Runnable mLoadingRunnable = new Runnable() {

  @Override
  public void run() {
    long endTime = System.currentTimeMillis();
  }
};       
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;ViewRootImpl会调用两次performTraversals，这时我们认为页面绘画完成了。View.post的Runnable任务会被加入任务队列，并且等待第一次TraversalRunnable执行结束后才执行；Handler.post代码会在第二次performTraversals后执行。   &lt;br /&gt;
该统计方法还是比较准确的，结束节点页面已经绘制完成&lt;sub&gt;&lt;font color=&quot;0099ff&quot; face=&quot;黑体&quot;&gt;[4]&lt;/font&gt;&lt;/sub&gt;。&lt;/p&gt;

&lt;p&gt;参考文章：
1:https://www.zhihu.com/question/35487841  &lt;br /&gt;
2.http://stackoverflow.com/questions/32844566/what-does-i-activitymanager-displayed-activity-850ms-comprised-of  &lt;br /&gt;
3.http://graphics-geek.blogspot.sg/2015/10/measuring-activity-startup-time.html?m=1  &lt;br /&gt;
4.http://androidperformance.com/2015/11/18/Android-app-lunch-optimize-delay-load.html&lt;/p&gt;

</description>
        <pubDate>Fri, 22 Apr 2016 11:12:05 +0800</pubDate>
        <link>http://yourdomain.com/android/optimize/2016/04/22/android-test-page-launch-time.html</link>
        <guid isPermaLink="true">http://yourdomain.com/android/optimize/2016/04/22/android-test-page-launch-time.html</guid>
        
        
        <category>Android</category>
        
        <category>Optimize</category>
        
      </item>
    
      <item>
        <title>Android 流畅性优化</title>
        <description>&lt;p&gt;页面流畅性是App非常重要的性能指标，下面总结一下流畅性优化容易出效果的点。
# 1.过度绘制优化&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;过度绘制检查&lt;/strong&gt; ：过度绘制指屏幕上的某个像素在同一帧的时间内被绘制了多次。
多层次重叠的UI结构里面，如果不可见的UI也在做绘制的操作，会导致某些像素区域被绘制了多次，从而会浪费大量的CPU以及GPU资源。 &lt;br /&gt;
过度绘制是页面流畅的大敌，Android对过度绘制有方便的检测手段：设置-&amp;gt;开发者选项-&amp;gt;调试GPU过度绘制-&amp;gt;显示过度绘制区域/显示过度绘制计数器。 &lt;br /&gt;
“显示过度绘制计数器”会统计某页面UI绘制的平均值，根据我个人的开发经验，2层以内的绘制数是最优值，一定要优化超过3层的过度绘制。 &lt;br /&gt;
&lt;strong&gt;检查多余背景&lt;/strong&gt; ：多余背景是最容易出现过度绘制的原因。通过细致的代码review可以发现很明显的多余背景；建议通过官方HierarchyViewer检查。    &lt;br /&gt;
在成功Load View Hierarchy后，在DecorView中执行Profile Node，就可以在布局节点中看到每个view的UI显示情况；我们可以从DecorView一直跟踪到页面中具体Widget的背景，排查并去掉多余背景。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;优化Theme过度绘制&lt;/strong&gt; 
举例来说，某页面层级是这样的： 
&lt;img src=&quot;http://121.42.160.4:8081/overdraw/android_overdraw.png&quot; alt=&quot;place holder&quot; /&gt;&lt;/p&gt;

&lt;p&gt;DecorView绘制了主题背景，RelativeLayout@25ec597作为Activity根布局也绘制了背景。很明显这里有OverDraw，两种方法可以优化： &lt;br /&gt;
1.把Theme中的background去掉,具体页面使用特定背景色； &lt;br /&gt;
2.使用Theme中的background作为统一背景色，页面根部局不再设置背景色。 &lt;br /&gt;
目前考虑到页面差异（如详情和列表背景色不一致），选择了第一种方式，修改方法是在Application和Activity的主题中都添加这行代码：&lt;/p&gt;

&lt;p&gt;&amp;lt;item name=”android:windowBackground”&amp;gt;@null&amp;lt;/item&amp;gt;    &lt;br /&gt;
巧合的是，在Android Developer的官方blog中也提到了这种优化方式。&lt;sub&gt;&lt;font color=&quot;0099ff&quot; face=&quot;黑体&quot;&gt;[1]&lt;/font&gt;&lt;/sub&gt;&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;2.优化布局层次&lt;/h1&gt;
&lt;p&gt;同上，对布局层级最准确的检测工具是Hierarchy Viewer. &lt;br /&gt;
&lt;strong&gt;include标签&lt;/strong&gt; 
确切说是用来实现重用布局，做到NRY。对优化布局层次无作用。
&lt;strong&gt;merge标签&lt;/strong&gt; ：
在可以使用时尽量使用，使用场景：
（1）父布局只有一个子布局，且该子布局和父布局是同一种布局时。
（2）根布局是frameLayout时，可以将其替换成merge标签。
（3）自定义布局时，尽量不使用padding；这样可以使用merge标签，减少一层布局。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LinearLayout/RelativieLayout&lt;/strong&gt;
一层的RelativeLayout效率高于两层LinearLayout，所以复杂的布局多使用RelativeLayout。 &lt;br /&gt;
如果相同层次的LinearLayout可以实现RelativeLayout的布局效果，显然使用LinearLayout。
layout_weight属性的LinearLayout会在绘制时花费昂贵的系统资源，因为每一个子组件都需要被测量两次；请尽量少使用。&lt;/p&gt;

&lt;h1 id=&quot;view-inflate&quot;&gt;3.减少不必要的view Inflate&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;ViewStub&lt;/strong&gt;  这里不得不提到ViewStub的使用。它提供了一种方便的LazyLoad方式，来处理Activity OnCreate中大量View Inflate造成的卡顿问题。 &lt;br /&gt;
回到业务场景，非常适合小概率需要显示的View使用：比如网络异常View,新手引导图等。  &lt;br /&gt;
用户操作触发的View显示：如edittext获取焦点后弹出的表情输入View。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ViewStub vs Gone&lt;/strong&gt; 我们在实际使用中，有很多布局是少概率出现的,比如网络异常布局，新手引导布局等。最合适的方式是使用ViewStub。 二者的效率差别在
参考文献2&lt;sub&gt;&lt;font color=&quot;0099ff&quot; face=&quot;黑体&quot;&gt;[2]&lt;/font&gt;&lt;/sub&gt;的第二个试验，作者测量了ViewStub和View.setVisibility(Gone)消耗Cpu时间，ViewStub的执行效率明显优于Gone. &lt;br /&gt;
作者结论如下: &lt;br /&gt;
Inflating a more complex layout, even when some views’ visibility are set to GONE, takes more time than inflating the simpler view, without the hidden views.&lt;/p&gt;

&lt;h1 id=&quot;decorviewpost&quot;&gt;4.DecorView.post()&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;http://banking.github.io/android/optimize/2016/04/22/android-test-page-launch-time.html&quot;&gt;上篇文章&lt;/a&gt;提到过，可以根据DecorView.post来测量页面启动时间。
同样此方案非常适合做页面启动时的流畅性优化,比如在updateYourUI()中执行影响页面启动性能的操作。示例代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;getWindow().getDecorView().post(new Runnable() {
    @Override
    public void run() {
        myHandler.post(mLoadingRunnable);
    }
});    

private Handler myHandler = new Handler();
private Runnable mLoadingRunnable = new Runnable() {

  @Override
  public void run() {
    updateYourUI(); 
  }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;traceview&quot;&gt;5.TraceView分析&lt;/h1&gt;
&lt;p&gt;建议使用TraceView分析页面启动时间点的cpu消耗。TraceView可以准确测量某时间区间内cpu时间片各函数执行情况，关注非UI更新类型的cpu消耗。可能导致Ui卡顿的常见场景:数据解析，数据库操作，网络等。 &lt;br /&gt;
&lt;strong&gt;优化例子&lt;/strong&gt; 下面是一个页面启动时的TraceView分析图：
&lt;img src=&quot;http://121.42.160.4:8081/overdraw/http_put_params_traceview.jpg&quot; alt=&quot;place holder&quot; /&gt;
可以看到，网络层封装http get参数占用了相当大比重的cpu时间片（约9%）。
原因分析：Volley框架中Request putParam是在主线程的。如果参数过多，或者有大段字符加密操作，会消耗主线程过多时间。  &lt;br /&gt;
优化方法：将大部分不变化的params做缓存，在内存中保留一个存放这些params的Map；在网络请求时直接执行putAll()操作。&lt;/p&gt;

&lt;p&gt;参考文献：
1.http://android-developers.blogspot.jp/2009/03/window-backgrounds-ui-speed.html
2.http://magicmicky.github.io/android_development/benchmark-using-traceview/&lt;/p&gt;
</description>
        <pubDate>Tue, 19 Apr 2016 13:55:04 +0800</pubDate>
        <link>http://yourdomain.com/android/optimize/2016/04/19/android-ui-optimize.html</link>
        <guid isPermaLink="true">http://yourdomain.com/android/optimize/2016/04/19/android-ui-optimize.html</guid>
        
        
        <category>Android</category>
        
        <category>Optimize</category>
        
      </item>
    
      <item>
        <title>Android 内存优化案例</title>
        <description>&lt;p&gt;整理一下顺风车4.2.4版本中的内存优化案例。&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;1.首页优化运营图背景&lt;/h1&gt;

&lt;p&gt;第一次通过Mat分析观察到了异常Bitmap对象,猜测和首页运营图相关。
&lt;img src=&quot;http://121.42.160.4:8081/memoryleak/EntranceFragment_image_exception1.png&quot; alt=&quot;place holder&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面可以看到已经定位到了业务代码BtsHomeImageView。
&lt;img src=&quot;http://121.42.160.4:8081/memoryleak/EntranceFragment_image_exception2.png&quot; alt=&quot;place holder&quot; /&gt;&lt;/p&gt;

&lt;p&gt;继续跟进这个控件，可以看到其父类BezelImageView在初始化时创建了一个bitmap作为背景。
&lt;img src=&quot;http://121.42.160.4:8081/memoryleak/EntranceFragment_image_exception3.png&quot; alt=&quot;place holder&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这是一个控件误用问题。BezelImageView通过画布裁切实现圆角效果，画布会一直保持mCacheBitmap的引用，不可为大图imageView使用。&lt;/p&gt;

&lt;h1 id=&quot;splashactiviy&quot;&gt;2.SplashActiviy内存泄露优化&lt;/h1&gt;

&lt;p&gt;SplashActivity的内存泄露是很严重的问题，会一直持有闪屏图引用。同样是在类似页面有发现，同时LeakCancary也有提醒。&lt;br /&gt;
&lt;img src=&quot;http://121.42.160.4:8081/memoryleak/SplashActivity_LeakCancary.jpg&quot; alt=&quot;place holder&quot; /&gt;
仍然是使用Mat追踪问题：
&lt;img src=&quot;http://121.42.160.4:8081/memoryleak/SplashActivity_Leak.png&quot; alt=&quot;place holder&quot; /&gt;
&lt;img src=&quot;http://121.42.160.4:8081/memoryleak/SplashActivity_Leak2.png&quot; alt=&quot;place holder&quot; /&gt;&lt;/p&gt;

&lt;p&gt;问题分析：广告的数据库,AdDbHelper是个单例,一直持有Activity,没有释放。
最新的theone-SDk 4.3.27已经修复该问题。&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;3.首页优化运营图大小&lt;/h1&gt;

&lt;p&gt;运营图在mat中的bitmap在这里。
&lt;img src=&quot;http://121.42.160.4:8081/memoryleak/Home_Operation_bitmap.png&quot; alt=&quot;place holder&quot; /&gt;&lt;/p&gt;

&lt;p&gt;发现一个奇怪的问题，第一次网络拉取运营图，RGB_8888,大小2242928byte.
第二次显示本地图，RGB_565,大小1121464byte。
回溯了一下glide源码，出现该问题的原因是gilde的一个特性。代码如下：
&lt;img src=&quot;http://121.42.160.4:8081/memoryleak/glide_prefer.png&quot; alt=&quot;place holder&quot; /&gt;&lt;/p&gt;

&lt;p&gt;后面有想过针对图片大小做优化，基于此做了一些测试，以下是小图显示效果，对比如下:
&lt;img src=&quot;http://121.42.160.4:8081/memoryleak/Operation_scale.png&quot; alt=&quot;place holder&quot; /&gt;&lt;/p&gt;

&lt;p&gt;具体配置标准见&lt;a href=&quot;http://banking.github.io/jekyll/update/2016/03/07/android-memory-optimize.html&quot;&gt;上篇文章&lt;/a&gt;。&lt;/p&gt;

&lt;h1 id=&quot;section-2&quot;&gt;4.详情页内存泄露优化&lt;/h1&gt;

&lt;p&gt;对于首页，详情页这样负责的页面，检查内存泄露有更简单的方法。
多次进入目标页面并返回，内存稳步增加，基本可以确定是泄露了。
初始内存：
&lt;img src=&quot;http://121.42.160.4:8081/memoryleak/Memory_check.png&quot; alt=&quot;place holder&quot; /&gt;&lt;/p&gt;

&lt;p&gt;进入页面十几次后内存：
&lt;img src=&quot;http://121.42.160.4:8081/memoryleak/Memory_check2.png&quot; alt=&quot;place holder&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以BtsOrderDetailForDriverActivity内存泄露为例,Dump内存后可以看到内存中一直存在多个实例。
&lt;img src=&quot;http://121.42.160.4:8081/memoryleak/Memory_check3.jpg&quot; alt=&quot;place holder&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每个实例占用150K空间。
&lt;img src=&quot;http://121.42.160.4:8081/memoryleak/Memory_check4.jpg&quot; alt=&quot;place holder&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果内存泄露暂时无法处理。保底方案：在Activity onDestory时候从view的rootview开始，递归释放所有子view涉及的图片，背景，DrawingCache，监听器等等资源，让Activity成为一个不占资源的空壳，泄露了也不会导致图片资源被持有。
详文在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;amp;mid=400656149&amp;amp;idx=1&amp;amp;sn=122b4f4965fafebf78ec0b4fce2ef62a&amp;amp;scene=1&amp;amp;srcid=0304Y3NE2XzzpXnciVmy8V3p&amp;amp;key=710a5d99946419d991561737ff21afe36087e30f7048e503c104b3e7f52184650009e924294d02ce511f14198c71a882&amp;amp;ascene=0&amp;amp;uin=MjQxMDYzNTU%3D&amp;amp;devicetype=iMac+MacBookAir5%2C2+OSX+OSX+10.11.3+build(15D21)&amp;amp;version=11000003&amp;amp;pass_ticket=C1SGUVOM%2FbWwXCSLYZ6k4PrmyBNZxI5EE66XuGZcRjk%3D&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;h1 id=&quot;immessageactivity&quot;&gt;5.IMMessageActivity引导图优化。&lt;/h1&gt;
&lt;p&gt;进入IM页面OOM崩溃问题是上版本的顽疾。初次进入发现激增20M内存，必然存在严重内存问题。
分析发现有异常大图出现。
&lt;img src=&quot;http://121.42.160.4:8081/memoryleak/IMMessageActivity_Guide_Exception1.png&quot; alt=&quot;place holder&quot; /&gt;
发现是一个引导图对象，属于初始化加载错误。
&lt;img src=&quot;http://121.42.160.4:8081/memoryleak/IMMessageActivity_Guide_Exception2.png&quot; alt=&quot;place holder&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;immessageactivity-1&quot;&gt;6.IMMessageActivity内存泄露优化。&lt;/h1&gt;
&lt;p&gt;IMMessageActivity页面存在多处内存泄露。引发原因多是（匿名）内部类持有activity引用没有释放引起。
比如这个：
&lt;img src=&quot;http://121.42.160.4:8081/memoryleak/IMMessageActivity_Leak.png&quot; alt=&quot;place holder&quot; /&gt;
在Activity的OnDestroy时及时解除引用就可以了。&lt;/p&gt;

</description>
        <pubDate>Fri, 11 Mar 2016 14:21:11 +0800</pubDate>
        <link>http://yourdomain.com/android/optimize/2016/03/11/memory-optimize-example.html</link>
        <guid isPermaLink="true">http://yourdomain.com/android/optimize/2016/03/11/memory-optimize-example.html</guid>
        
        
        <category>Android</category>
        
        <category>Optimize</category>
        
      </item>
    
      <item>
        <title>Welcome to Jekyll!</title>
        <description>&lt;p&gt;I am new to jekyll.&lt;/p&gt;

&lt;p&gt;这里记载一下Jekyll的使用方法。&lt;/p&gt;

&lt;p&gt;1.Rakefile拷贝自这里：https://github.com/chenxsan/chenxsan.github.io/blob/master/Rakefile
需要新建时，在根目录下执行 rake new.按照提示步骤输入即可。&lt;/p&gt;

&lt;p&gt;2.jekyll server 可以在localhost:4000看到文章预览效果&lt;/p&gt;

&lt;p&gt;3.jekyll build 构建文章。md –&amp;gt; html&lt;/p&gt;

&lt;p&gt;Check out the &lt;a href=&quot;http://jekyllrb.com/docs/home&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://talk.jekyllrb.com/&quot;&gt;Jekyll Talk&lt;/a&gt;.&lt;/p&gt;

</description>
        <pubDate>Mon, 07 Mar 2016 19:57:04 +0800</pubDate>
        <link>http://yourdomain.com/jekyll/skill/2016/03/07/welcome-to-jekyll.html</link>
        <guid isPermaLink="true">http://yourdomain.com/jekyll/skill/2016/03/07/welcome-to-jekyll.html</guid>
        
        
        <category>Jekyll</category>
        
        <category>Skill</category>
        
      </item>
    
      <item>
        <title>Android 内存优化方案和总结</title>
        <description>&lt;h1 id=&quot;activity&quot;&gt;1.Activity内存泄露检查&lt;/h1&gt;
&lt;p&gt;使用LeakCancary,Memory Dump,Mat分析。  &lt;br /&gt;
&lt;strong&gt;Memory Dump&lt;/strong&gt;：检测手段最简单。在Package Tree View页面筛选，理论上，检测任何到activity个数&amp;gt;1都应该提出质疑。  &lt;br /&gt;
&lt;strong&gt;LeakCancary&lt;/strong&gt;：配置方便，也比较准确。Launcher中打开Leaks就可以查看到内存泄露的Activity汇总。  &lt;br /&gt;
&lt;strong&gt;Mat&lt;/strong&gt;：最全面，但稍显复杂。需要查看Histogram中异常Activity个数，观察手动gc后某些activity是否及时销毁，对业务代码的熟悉程度有较高要求。  &lt;br /&gt;
&lt;strong&gt;解决方案&lt;/strong&gt; ：相关RD检查代码，是否有持有context引用未释放的情况，并修复之。禁止外部静态单例强引用context.&lt;br /&gt;
&lt;strong&gt;进度&lt;/strong&gt; ： 目前已经修复SplashActivity内存泄露，IM会话详情Activity内存泄露；乘客详情Activity，司机详情Activity由腾讯地图引起，正在推动解决。&lt;/p&gt;

&lt;h1 id=&quot;bitmap&quot;&gt;2.Bitmap优化异常&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;异常大图对象&lt;/strong&gt; 
属于代码逻辑错误导致的，在打开某些页面时，进行Memory检测,如果内存有异常增长，可以确认问题存在。&lt;br /&gt;
&lt;strong&gt;解决方案&lt;/strong&gt; ：打开页面后立刻dump memory，并使用mat分析。在Dominator Tree定位异常bitmap对象引用，检查代码修复。&lt;br /&gt;
&lt;strong&gt;进度&lt;/strong&gt; ：顺风车首页解决了一个误用控件绘制bitmap背景的问题；IM详情页解决了一个过早初始化新手引导图的问题。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;现有图片瘦身&lt;/strong&gt; 
打开目标页面，dump memory heap，并用mat分析内存对象。锁定大块bitmap对象，定位到其业务代码归属 。建议运营图不要超过1M，全屏浮层图大小不要超过4M。&lt;br /&gt;
bitmap在内存中大小计算规则：长&lt;em&gt;宽&lt;/em&gt;单像素内存大小。有alpha通道的RGB_8888单像素占内存4byte,无alpha通道的RGB_565单像素占内存2byte.&lt;br /&gt;
&lt;strong&gt;解决方案&lt;/strong&gt; ： 所有网络下发的大图采用无alpha通道的jpg格式，而不是png。服务器配置多图，客户端根据手机分辨率拉取合适的图。结合UI同事建议，需要保持2/3以上的失真率。&lt;br /&gt;
以顺风车首页运营图为例，配置两套图，分别为1066x526和720x356。1920x1080屏幕的手机，可以选择720x356图；更大屏幕手机选择1066x526。
注意长宽一定保持等比拉伸。&lt;br /&gt;
&lt;strong&gt;进度&lt;/strong&gt; ：目前顺风车首页运营图格式已经优化；图片大小配置需要配合API和UI同事进行。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section&quot;&gt;3.代码层面优化。&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;store优化&lt;/strong&gt;&lt;br /&gt;
TheOne框架引中，引入了store管理activity逻辑的代码架构。提供了快速创建Sotre单例的方式:SingletonHolder.getInstance(XXX.class)。
但是SingletonHolder用了强引用的方式缓存了sore对象，导致store会一直存在于内存中。&lt;br /&gt;
&lt;strong&gt;解决方案&lt;/strong&gt; ：
1.如果store为单个activity服务，建议不采用单例方式，直接new来创建store对象&lt;br /&gt;
2.如果store为多个activity服务，必须有clear方法，结合业务需求清除store内部的数据和对象。在某些业务逻辑触发后（比如发单成功后清理PublishStroe)。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;其他代码层面优化&lt;/strong&gt;&lt;br /&gt;
减少静态单例使用。静态单例多在工具类中出现，视业务区分，不要过度使用静态单例，并注意适时回收。&lt;br /&gt;
减少enum使用，使用SparseArray取代Map等。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;omegaoom-&quot;&gt;4.跟踪Omega线上异常，在触发OOM 节点检查代码。&lt;/h1&gt;
&lt;p&gt;触发oom时一般会需要大量的内存分配，才导致OOM错误。&lt;br /&gt;
以顺风车为例。前三项OOM异常，分别是：   &lt;br /&gt;
（1）IM详情页OnCreate时触发。  &lt;br /&gt;
（2）订单详情页OnCreate时触发。   &lt;br /&gt;
（3） 网络解析response json时触发。  &lt;br /&gt;
内存优化是否成功的检查唯一标准，一定是线上OOM爆发量是否减少。所以在触发OOM的节点，一点也要做细致的code review。&lt;br /&gt;
&lt;strong&gt;进度&lt;/strong&gt;：目前在三处都检查到了一些问题，做以下优化。&lt;br /&gt;
（1）IM详情页 发现了一个进入页面后所有gif表情，轮播多次的异常逻辑。已修复。&lt;br /&gt;
（2）订单详情页 有内存泄露情况发生。&lt;br /&gt;
（3）列表页pageNum = 30 导致回文过大（目前是160KB)，考虑优化pageNum = 15。&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;5.追踪内存分配&lt;/h1&gt;
&lt;p&gt;Allocation Traker来查看内存到底被什么占用了;获取alloc文件。&lt;/p&gt;

</description>
        <pubDate>Mon, 07 Mar 2016 19:57:04 +0800</pubDate>
        <link>http://yourdomain.com/jekyll/update/2016/03/07/android-memory-optimize.html</link>
        <guid isPermaLink="true">http://yourdomain.com/jekyll/update/2016/03/07/android-memory-optimize.html</guid>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
  </channel>
</rss>
